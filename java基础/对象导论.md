##### 1. 抽象过程
    1.1 所有语言都提供抽象机制。人们所能解决问题的复杂性直接取决于抽象的类型和质量。  
    1.2 抽象的类型
    - 主要抽象要求在解决问题时基于计算机的结构，而不是基于要解决的问题的结构来考虑。例如汇编语言、BASIC、C，程序员需要建立机器模型（位于解空间内，对于问题建模的地方，如计算机）和实际待解决的问题的模型（位于问题空间内，问题存在的地方，如某一项业务）之间的关联。
    - 只针对待解决问题的建模。对于所要解决的特定类型的问题都是不错的解决方案，但是一旦超出特定领域，力不从心。
    1.3 面向对象方式  
    将问题空间中的元素及其在解空间中的表示称为“对象”。程序可以添加新的类型的对象使自身适用于某个特定的问题。因此，在阅读描述解决方案的代码的同时也是在阅读问题的描述。OOP允许根据问题来描述问题，而不是根据运行解决方案的计算机来描述问题。它仍然与计算机：每个对象看起来有点像计算机，它具有状态、操作，用户可以要求对象执行这些操作。
    1.4 面向对象的特性
    - 万物皆对象
    - 程序是对象的集合，它们通过发消息来告知彼此要做的。即对某个特定对象的方法的调用。
    - 每个对象都有自己的由其他对象所构成的存储。即可以创建包含现有对象的包的方式来创建新类型的对象。
    - 每个对象都有其类型。
    - 某一特定类型的所有对象都可以接受相同的消息。继承时，父子属于同一类型（父）的对象，子必须能处理父所有的代码。  
    **对象具有状态、行为、标识。**
##### 2. 每个对象都有一个接口
##### 3. 每个对象都提供服务
##### 4. 被隐藏的具体实现   
&emsp;&emsp;开发人员根据角色可以分为类创建者、客户端程序员。在任何相互关系中， 具有关系所涉及的各方面都遵守的边界是十分重要的事情。访问控制的原因：
- 让客户端程序员无法触及到他们不应该触及的部分
- 允许类库的设计者可以改变类的内部实现的工作方式而不用担心会影响到客户端程序员
##### 5. 复用的具体实现
组合： has-a
##### 6. 继承
- 导出类和基类具有相同的类型
- “是一个”和“像是一个”  
“是一个”：导出类与基类具有完全相同的类型，导出类对象可以完全替代一个基类对象。纯粹替代，替代原则，是“is-a”关系。  
“像是一个”：导出类添加新的接口元素，新基类仍可以替代基类，但不完美，基类无法访问新添加的方法。是“is-like-a”关系
##### 7. 伴随多态的可互换对象
- 前期绑定：编译器将产生对一个具体函数名字的调用，在运行时将这个调用解析到被执行代码的绝对地址
- 后期绑定：编译器确保被调用方法存在，并对调用参数和返回值进行类型检查，但是并不知道将被执行的具体代码。
- 向上转型：将导出类看作是它的基类的过程
##### 8. 单根继承结构
- 所有的类是相同的基本结构（实现全系统多态）
- 保证所有对象具有某些功能
- 单根继承结构使得垃圾回收器容易实现
##### 9. 容器
&emsp;&emsp;在任何需要时都可以扩充自己以容纳置于其中的所有东西，所以不需要知道将来会把多少个对象置于容器中，只需要创建一个容器对象，然后让它处理所有细节  
&emsp;&emsp;参数化类型（范型）：解决向下转型问题
##### 10. 对象创建和生命周期
- 对象的存储空间和生命周期可以在编写程序时确定，通过将对象置于堆栈或静态存储区实现。
- 在堆内存池中动态创建对象，在运行时才知道有多少对象，它们的生命周期，以及它们的具体类型
##### 11. 异常处理
##### 12. 并发编程


----
##### 其他
1. **组合与聚合**
```java

public class Person {
    Brain brain;
    public Person(){//组合
        brain=new Brain();
    }
 
    public static void main(String[] args) {
        Person person=new Person();
    }
 
}
class Brain{
 
}



public class Human {
    Computer computer;
    Human(Computer computer1){
        computer=computer1;
    }
 
    public static void main(String[] args) {
        Computer c=new Computer();//聚合
        Human h=new Human(c);
    }
}
class Computer{
    
}
```
2. **为什么单根继承能使得垃圾回收机制实现更容易**？

3. **替换原则**  
里氏替换原则是一个非常有用的一个概念。他的定义
> 如果对每一个类型为T1的对象o1,都有类型为T2的对象o2,使得以T1定义的所有程序P在所有对象o1都替换成o2的时候，程序P的行为都没有发生变化，那么类型T2是类型T1的子类型。

这样说有点复杂，其实有一个简单的定义
所有引用基类的地方必须能够透明地使用其子类的对象。
里氏替换原则通俗的去讲就是：子类可以去扩展父类的功能，但是不能改变父类原有的功能。他包含以下几层意思：
- 子类可以实现父类的抽象方法，但是不能覆盖父类的非抽象方法。
- 子类可以增加自己独有的方法。
- 当子类的方法重载父类的方法时候，方法的形参要比父类的方法的输入参数更加宽松。
- 当子类的方法实现父类的抽象方法时，方法的返回值要比父类更严格。